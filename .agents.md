# AI Agents Guide for sqlc-gen-csharp Repository

This guide provides comprehensive instructions for AI agents working with the sqlc-gen-csharp repository, a C# code generator for the sqlc project.

## Repository Overview

**Purpose**: A C# code generator plugin for sqlc that generates type-safe C# code from SQL queries.

**Key Technologies**:
- .NET 8.0 / C#
- PostgreSQL, MySQL, SQLite support
- Protocol Buffers for sqlc communication
- NUnit for testing
- Docker for E2E test infrastructure

**Architecture**:
- `CodeGenerator/`: Core code generation logic
- `Drivers/`: Database-specific implementations
- `Examples/`: Generated code examples for each database
- `end2end/`: End-to-end test framework
- `PluginOptions/`: Configuration handling

## Essential Files and Directories

### Core Implementation
- `CodeGenerator/Generators/QueriesGen.cs`: **CRITICAL** - SQL query code generation
- `Drivers/`: Database-specific drivers (NpgsqlDriver, MySqlConnectorDriver, SqliteDriver)
- `PluginOptions/Options.cs`: Plugin configuration options

### Test Infrastructure
- `end2end/EndToEndScaffold/`: Test case generation framework
- `end2end/EndToEndScaffold/Templates/`: Test implementation templates
- `end2end/EndToEndScaffold/Config.cs`: Test type definitions and configurations
- `examples/config/`: SQL schemas and queries for each database

### Build System
- `Makefile`: **PRIMARY BUILD INTERFACE** - All operations must use Makefile
- `sqlc.local.generated.yaml`: Local sqlc configuration
- `sqlc.ci.yaml`: CI/production sqlc configuration

## Essential Development Workflow

### 1. Making Code Changes
```bash
# Always build first
make dotnet-build

# Generate examples (when changing code generation logic)
make sqlc-generate

# Generate E2E tests (when adding new test cases)
make generate-end2end-tests

# Run all tests
make run-end2end-tests
```

### 2. Adding New Test Cases

**Step 1**: Add test type to `end2end/EndToEndScaffold/Config.cs`
```csharp
// In enum KnownTestType
YourNewTestType,

// In appropriate test type sets (_postgresTestTypes, _mysqlTestTypes, _sqliteTestTypes)
KnownTestType.YourNewTestType,
```

**Step 2**: Add SQL schema/queries to appropriate `examples/config/{database}/authors/` files

**Step 3**: Add test implementation in `end2end/EndToEndScaffold/Templates/{Database}Tests.cs`
```csharp
[KnownTestType.YourNewTestType] = new TestImpl
{
    Impl = $$"""
             [Test]
             public async Task TestYourFeature()
             {
                 // Test implementation
             }
             """
}
```

**Step 4**: Regenerate and test
```bash
make sqlc-generate
make generate-end2end-tests
make run-end2end-tests
```

### 3. Database-Specific Considerations

**PostgreSQL**:
- Uses double quotes for identifiers: `"table"`
- Supports RETURNING clauses: `:one`, `:many`
- Connection: `Npgsql.NpgsqlConnection`

**MySQL**:
- Uses backticks for identifiers: `` `table` ``
- Limited RETURNING support: prefer `:exec`
- Connection: `MySqlConnector.MySqlConnection`

**SQLite**:
- Uses double quotes for identifiers: `"table"`
- Limited type system: prefer TEXT, INTEGER
- Connection: `Microsoft.Data.Sqlite.SqliteConnection`

## Common Code Generation Patterns

### 1. SQL String Escaping (CRITICAL)
When generating SQL constants in C#, quotes must be escaped:
```csharp
// In QueriesGen.cs
var escapedQueryText = singleLineQueryText.Replace("\"", "\\\"");
```

### 2. Test Case Structure
```csharp
[Test]
public async Task TestFeatureName()
{
    // 1. Setup data (if needed)
    var connection = new SomeConnection(Environment.GetEnvironmentVariable(EndToEndCommon.SomeConnectionStringEnv));
    await connection.OpenAsync();
    // Raw SQL setup if needed
    
    // 2. Execute generated method
    var result = await QuerySql.SomeMethod(new QuerySql.SomeMethodArgs { ... });
    
    // 3. Assertions
    Assert.That(result, Is.Not.Null);
    Assert.That(result.SomeProperty, Is.EqualTo(expectedValue));
    
    // 4. Cleanup
    connection.Close();
}
```

### 3. Database Connection Environment Variables
- PostgreSQL: `EndToEndCommon.PostgresConnectionStringEnv`
- MySQL: `EndToEndCommon.MySqlConnectionStringEnv`  
- SQLite: `EndToEndCommon.SqliteConnectionStringEnv`

## Critical Rules and Constraints

### 1. Makefile Usage
**NEVER** run commands directly. Always use Makefile:
- ❌ `dotnet build`
- ✅ `make dotnet-build`
- ❌ `sqlc generate`
- ✅ `make sqlc-generate`

### 2. File Edit Patterns
When editing files, always include 3-5 lines of context for unambiguous matching:
```csharp
// Good pattern for replace_string_in_file
oldString: """
    existing line 1
    existing line 2
    LINE TO CHANGE
    existing line 3
    existing line 4
"""
```

### 3. SQL Syntax Database Differences
- PostgreSQL: `$1, $2` parameters, `"quoted"` identifiers
- MySQL: `?, ?` parameters, `` `quoted` `` identifiers  
- SQLite: `?, ?` parameters, `"quoted"` identifiers

### 4. Test Organization
- Keep tests minimal and focused
- Extend existing schemas rather than creating new files
- Use generic names (e.g., `updated_at` not `last_seen_at`)
- Each database engine needs its own test implementation

## Debugging and Troubleshooting

### Common Issues

1. **Compilation Errors**: Check generated examples in `examples/*/QuerySql.cs`
2. **Test Failures**: Examine specific test output and database logs
3. **SQL Generation Issues**: Check `QueriesGen.cs` and driver implementations
4. **Schema Issues**: Verify database-specific SQL syntax in `examples/config/`

### Validation Steps
```bash
# Check if code compiles
make dotnet-build

# Verify examples generate correctly  
make sqlc-generate

# Ensure all tests pass
make run-end2end-tests

# Check specific example output
grep -r "YourQueryName" examples/
```

### Docker Infrastructure
E2E tests use Docker containers for databases:
- `docker-compose.yml` defines the test database setup
- Containers auto-start during `make run-end2end-tests`
- Database schemas loaded from `examples/config/{database}/`

## File Change Impact Analysis

| File Changed | Required Actions |
|--------------|------------------|
| `CodeGenerator/**` | `make sqlc-generate`, `make run-end2end-tests` |
| `Drivers/**` | `make sqlc-generate`, `make run-end2end-tests` |
| `examples/config/**` | `make sqlc-generate`, `make generate-end2end-tests`, `make run-end2end-tests` |
| `end2end/EndToEndScaffold/Templates/**` | `make generate-end2end-tests`, `make run-end2end-tests` |
| Test configurations | `make generate-end2end-tests`, `make run-end2end-tests` |

## Quality Checklist

Before completing any changes:
- [ ] All code compiles (`make dotnet-build`)
- [ ] Examples generate without errors (`make sqlc-generate`)
- [ ] Test code generates (`make generate-end2end-tests`)
- [ ] All E2E tests pass (`make run-end2end-tests`)
- [ ] SQL strings properly escaped in generated C#
- [ ] Database-specific syntax respected
- [ ] Test coverage includes all supported databases (PostgreSQL, MySQL, SQLite)

## Example: Adding Quoted Identifiers Support

This was a real example implemented in this repository:

1. **Problem**: SQL with quoted identifiers (`"user"`) generated invalid C# strings
2. **Root Cause**: `QueriesGen.cs` didn't escape quotes in SQL string literals
3. **Solution**: Added `singleLineQueryText.Replace("\"", "\\\"")` in `GetQueryTextConstant()`
4. **Testing**: Added comprehensive tests across all database engines
5. **Verification**: All 285 E2E tests pass

This demonstrates the full workflow from problem identification to comprehensive solution.