// auto-generated by sqlc - do not edit
// ReSharper disable UseObjectOrCollectionInitializer
// ReSharper disable UseAwaitUsing
// ReSharper disable ConvertToUsingDeclaration
// ReSharper disable NotAccessedPositionalProperty.Global
// ReSharper disable UnusedAutoPropertyAccessor.Global
namespace NpgsqlLegacyExampleGen
{
    using NodaTime;
    using NodaTime.Extensions;
    using Npgsql;
    using Npgsql.NameTranslation;
    using NpgsqlTypes;
    using System;
    using System.Collections.Generic;
    using System.Data;
    using System.Net;
    using System.Net.NetworkInformation;
    using System.Text.Json;
    using System.Threading.Tasks;
    using System.Xml;

    public class QuerySql
    {
        public QuerySql()
        {
        }

        public QuerySql(NpgsqlDataSource dataSource) : this()
        {
            this.DataSource = dataSource;
            this.ConnectionString = dataSource.ConnectionString;
        }

        private QuerySql(NpgsqlTransaction transaction) : this()
        {
            this.Transaction = transaction;
        }

        public static QuerySql WithTransaction(NpgsqlTransaction transaction)
        {
            return new QuerySql(transaction);
        }

        public static void ConfigureEnumMappings(NpgsqlDataSourceBuilder dataSourceBuilder)
        {
            dataSourceBuilder.MapEnum<AuthorsStatus>("authors_status");
            dataSourceBuilder.MapEnum<CEnum>("c_enum");
            dataSourceBuilder.MapEnum<ExtendedBioType>("bio_type");
        }

        // This being generated code, we can suppress the warning about non-nullable fields not being initialized
        private NpgsqlTransaction Transaction { get; } = null !;
        private NpgsqlDataSource DataSource { get; } = null !;
        private string ConnectionString { get; }

        private const string GetAuthorSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE name = @name LIMIT 1";
        public class GetAuthorRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorArgs
        {
            public string Name { get; set; }
        };
        public async Task<GetAuthorRow> GetAuthor(GetAuthorArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorSql))
                {
                    command.Parameters.AddWithValue("@name", args.Name);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetAuthorRow
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name", args.Name);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetAuthorRow
                        {
                            Id = reader.GetInt64(0),
                            Name = reader.GetString(1),
                            Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                            Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                            Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                        };
                    }
                }
            }

            return null;
        }

        private const string GetAuthorEmbedSql = "SELECT authors.id, authors.name, authors.bio, authors.created_at, authors.updated_at, authors.metadata, authors.status FROM authors WHERE name = @name LIMIT 1";
        public class GetAuthorEmbedRow
        {
            public Author Author { get; set; }
        };
        public class GetAuthorEmbedArgs
        {
            public string Name { get; set; }
        };
        public async Task<GetAuthorEmbedRow> GetAuthorEmbed(GetAuthorEmbedArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorEmbedSql))
                {
                    command.Parameters.AddWithValue("@name", args.Name);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetAuthorEmbedRow
                            {
                                Author = new Author
                                {
                                    Id = reader.GetInt64(0),
                                    Name = reader.GetString(1),
                                    Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                    CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                    UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                    Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                    Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                                }
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorEmbedSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name", args.Name);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetAuthorEmbedRow
                        {
                            Author = new Author
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            }
                        };
                    }
                }
            }

            return null;
        }

        private const string ListAuthorsSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors ORDER BY name LIMIT @limit OFFSET @offset";
        public class ListAuthorsRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class ListAuthorsArgs
        {
            public int Offset { get; set; }
            public int Limit { get; set; }
        };
        public async Task<List<ListAuthorsRow>> ListAuthors(ListAuthorsArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(ListAuthorsSql))
                {
                    command.Parameters.AddWithValue("@offset", args.Offset);
                    command.Parameters.AddWithValue("@limit", args.Limit);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<ListAuthorsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new ListAuthorsRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = ListAuthorsSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@offset", args.Offset);
                command.Parameters.AddWithValue("@limit", args.Limit);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<ListAuthorsRow>();
                    while (await reader.ReadAsync())
                        result.Add(new ListAuthorsRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                    return result;
                }
            }
        }

        private const string UpdateAuthorStatusSql = "UPDATE authors SET status = @status::authors_status WHERE id = @id";
        public class UpdateAuthorStatusArgs
        {
            public AuthorsStatus Status { get; set; }
            public long Id { get; set; }
        };
        public async Task UpdateAuthorStatus(UpdateAuthorStatusArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(UpdateAuthorStatusSql))
                {
                    command.Parameters.AddWithValue("@status", args.Status);
                    command.Parameters.AddWithValue("@id", args.Id);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = UpdateAuthorStatusSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@status", args.Status);
                command.Parameters.AddWithValue("@id", args.Id);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string CreateAuthorSql = "INSERT INTO authors (id, name, bio) VALUES (@id, @name, @bio) RETURNING id, name, bio, created_at, updated_at, metadata, status";
        public class CreateAuthorRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class CreateAuthorArgs
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
        };
        public async Task<CreateAuthorRow> CreateAuthor(CreateAuthorArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateAuthorSql))
                {
                    command.Parameters.AddWithValue("@id", args.Id);
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new CreateAuthorRow
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateAuthorSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@id", args.Id);
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new CreateAuthorRow
                        {
                            Id = reader.GetInt64(0),
                            Name = reader.GetString(1),
                            Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                            Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                            Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                        };
                    }
                }
            }

            return null;
        }

        private const string CreateAuthorIncludingCommentSql = "INSERT INTO authors ( id, name, bio ) VALUES (@id, @name, @bio) RETURNING id, name, bio, created_at, updated_at, metadata, status";
        public class CreateAuthorIncludingCommentRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class CreateAuthorIncludingCommentArgs
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
        };
        public async Task<CreateAuthorIncludingCommentRow> CreateAuthorIncludingComment(CreateAuthorIncludingCommentArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateAuthorIncludingCommentSql))
                {
                    command.Parameters.AddWithValue("@id", args.Id);
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new CreateAuthorIncludingCommentRow
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateAuthorIncludingCommentSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@id", args.Id);
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new CreateAuthorIncludingCommentRow
                        {
                            Id = reader.GetInt64(0),
                            Name = reader.GetString(1),
                            Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                            Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                            Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                        };
                    }
                }
            }

            return null;
        }

        private const string CreateAuthorReturnIdSql = "INSERT INTO authors (name, bio) VALUES (@name, @bio) RETURNING id";
        public class CreateAuthorReturnIdRow
        {
            public long Id { get; set; }
        };
        public class CreateAuthorReturnIdArgs
        {
            public string Name { get; set; }
            public string Bio { get; set; }
        };
        public async Task<long> CreateAuthorReturnId(CreateAuthorReturnIdArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateAuthorReturnIdSql))
                {
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                    var result = await command.ExecuteScalarAsync();
                    return Convert.ToInt64(result);
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateAuthorReturnIdSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                var result = await command.ExecuteScalarAsync();
                return Convert.ToInt64(result);
            }
        }

        private const string CreateAuthorEmbedSql = "INSERT INTO authors (id, name, bio) VALUES (@id, @name, @bio) RETURNING authors.id, authors.name, authors.bio, authors.created_at, authors.updated_at, authors.metadata, authors.status";
        public class CreateAuthorEmbedRow
        {
            public Author Author { get; set; }
        };
        public class CreateAuthorEmbedArgs
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
        };
        public async Task<CreateAuthorEmbedRow> CreateAuthorEmbed(CreateAuthorEmbedArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateAuthorEmbedSql))
                {
                    command.Parameters.AddWithValue("@id", args.Id);
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new CreateAuthorEmbedRow
                            {
                                Author = new Author
                                {
                                    Id = reader.GetInt64(0),
                                    Name = reader.GetString(1),
                                    Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                    CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                    UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                    Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                    Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                                }
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateAuthorEmbedSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@id", args.Id);
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new CreateAuthorEmbedRow
                        {
                            Author = new Author
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            }
                        };
                    }
                }
            }

            return null;
        }

        private const string GetAuthorByIdSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE id = @id LIMIT 1";
        public class GetAuthorByIdRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorByIdArgs
        {
            public long Id { get; set; }
        };
        public async Task<GetAuthorByIdRow> GetAuthorById(GetAuthorByIdArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorByIdSql))
                {
                    command.Parameters.AddWithValue("@id", args.Id);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetAuthorByIdRow
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorByIdSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@id", args.Id);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetAuthorByIdRow
                        {
                            Id = reader.GetInt64(0),
                            Name = reader.GetString(1),
                            Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                            Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                            Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                        };
                    }
                }
            }

            return null;
        }

        private const string GetAuthorByNamePatternSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE name LIKE COALESCE(@name_pattern, '%')";
        public class GetAuthorByNamePatternRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorByNamePatternArgs
        {
            public string NamePattern { get; set; }
        };
        public async Task<List<GetAuthorByNamePatternRow>> GetAuthorByNamePattern(GetAuthorByNamePatternArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorByNamePatternSql))
                {
                    command.Parameters.AddWithValue("@name_pattern", args.NamePattern ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetAuthorByNamePatternRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetAuthorByNamePatternRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorByNamePatternSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name_pattern", args.NamePattern ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetAuthorByNamePatternRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetAuthorByNamePatternRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                    return result;
                }
            }
        }

        private const string DeleteAuthorSql = "DELETE FROM authors WHERE name = @name";
        public class DeleteAuthorArgs
        {
            public string Name { get; set; }
        };
        public async Task DeleteAuthor(DeleteAuthorArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(DeleteAuthorSql))
                {
                    command.Parameters.AddWithValue("@name", args.Name);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = DeleteAuthorSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name", args.Name);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string TruncateAuthorsSql = "TRUNCATE TABLE authors CASCADE";
        public async Task TruncateAuthors()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncateAuthorsSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncateAuthorsSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string UpdateAuthorsSql = "UPDATE authors SET bio = @bio WHERE bio IS NOT NULL";
        public class UpdateAuthorsArgs
        {
            public string Bio { get; set; }
        };
        public async Task<long> UpdateAuthors(UpdateAuthorsArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(UpdateAuthorsSql))
                {
                    command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                    return await command.ExecuteNonQueryAsync();
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = UpdateAuthorsSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                return await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetAuthorsByIdsSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE id = ANY(@longArr_1::BIGINT [])";
        public class GetAuthorsByIdsRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorsByIdsArgs
        {
            public long[] LongArr1 { get; set; }
        };
        public async Task<List<GetAuthorsByIdsRow>> GetAuthorsByIds(GetAuthorsByIdsArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorsByIdsSql))
                {
                    command.Parameters.AddWithValue("@longArr_1", args.LongArr1);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetAuthorsByIdsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetAuthorsByIdsRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorsByIdsSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@longArr_1", args.LongArr1);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetAuthorsByIdsRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetAuthorsByIdsRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                    return result;
                }
            }
        }

        private const string GetAuthorsByIdsAndNamesSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE id = ANY(@longArr_1::BIGINT []) AND name = ANY(@stringArr_2::TEXT [])";
        public class GetAuthorsByIdsAndNamesRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorsByIdsAndNamesArgs
        {
            public long[] LongArr1 { get; set; }
            public string[] StringArr2 { get; set; }
        };
        public async Task<List<GetAuthorsByIdsAndNamesRow>> GetAuthorsByIdsAndNames(GetAuthorsByIdsAndNamesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorsByIdsAndNamesSql))
                {
                    command.Parameters.AddWithValue("@longArr_1", args.LongArr1);
                    command.Parameters.AddWithValue("@stringArr_2", args.StringArr2);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetAuthorsByIdsAndNamesRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetAuthorsByIdsAndNamesRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorsByIdsAndNamesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@longArr_1", args.LongArr1);
                command.Parameters.AddWithValue("@stringArr_2", args.StringArr2);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetAuthorsByIdsAndNamesRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetAuthorsByIdsAndNamesRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                    return result;
                }
            }
        }

        private const string CreateBookSql = "INSERT INTO books (name, author_id) VALUES (@name, @author_id) RETURNING id";
        public class CreateBookRow
        {
            public Guid Id { get; set; }
        };
        public class CreateBookArgs
        {
            public string Name { get; set; }
            public long AuthorId { get; set; }
        };
        public async Task<Guid> CreateBook(CreateBookArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateBookSql))
                {
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@author_id", args.AuthorId);
                    var result = await command.ExecuteScalarAsync();
                    return Guid.Parse(result?.ToString());
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateBookSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@author_id", args.AuthorId);
                var result = await command.ExecuteScalarAsync();
                return Guid.Parse(result?.ToString());
            }
        }

        private const string ListAllAuthorsBooksSql = "SELECT authors.id, authors.name, authors.bio, authors.created_at, authors.updated_at, authors.metadata, authors.status, books.id, books.name, books.author_id, books.description FROM authors INNER JOIN books ON authors.id = books.author_id ORDER BY authors.name";
        public class ListAllAuthorsBooksRow
        {
            public Author Author { get; set; }
            public Book Book { get; set; }
        };
        public async Task<List<ListAllAuthorsBooksRow>> ListAllAuthorsBooks()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(ListAllAuthorsBooksSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<ListAllAuthorsBooksRow>();
                        while (await reader.ReadAsync())
                            result.Add(new ListAllAuthorsBooksRow { Author = new Author { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() }, Book = new Book { Id = reader.GetFieldValue<Guid>(7), Name = reader.GetString(8), AuthorId = reader.GetInt64(9), Description = reader.IsDBNull(10) ? null : reader.GetString(10) } });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = ListAllAuthorsBooksSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<ListAllAuthorsBooksRow>();
                    while (await reader.ReadAsync())
                        result.Add(new ListAllAuthorsBooksRow { Author = new Author { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() }, Book = new Book { Id = reader.GetFieldValue<Guid>(7), Name = reader.GetString(8), AuthorId = reader.GetInt64(9), Description = reader.IsDBNull(10) ? null : reader.GetString(10) } });
                    return result;
                }
            }
        }

        private const string GetDuplicateAuthorsSql = "SELECT authors1.id, authors1.name, authors1.bio, authors1.created_at, authors1.updated_at, authors1.metadata, authors1.status, authors2.id, authors2.name, authors2.bio, authors2.created_at, authors2.updated_at, authors2.metadata, authors2.status FROM authors AS authors1 INNER JOIN authors AS authors2 ON authors1.name = authors2.name WHERE authors1.id < authors2.id";
        public class GetDuplicateAuthorsRow
        {
            public Author Author { get; set; }
            public Author Author2 { get; set; }
        };
        public async Task<List<GetDuplicateAuthorsRow>> GetDuplicateAuthors()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetDuplicateAuthorsSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetDuplicateAuthorsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetDuplicateAuthorsRow { Author = new Author { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() }, Author2 = new Author { Id = reader.GetInt64(7), Name = reader.GetString(8), Bio = reader.IsDBNull(9) ? null : reader.GetString(9), CreatedAt = reader.IsDBNull(10) ? (DateTime? )null : reader.GetDateTime(10), UpdatedAt = reader.IsDBNull(11) ? (DateTime? )null : reader.GetDateTime(11), Metadata = reader.IsDBNull(12) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(12)), Status = reader.IsDBNull(13) ? null : reader.GetString(13).ToAuthorsStatus() } });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetDuplicateAuthorsSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetDuplicateAuthorsRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetDuplicateAuthorsRow { Author = new Author { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() }, Author2 = new Author { Id = reader.GetInt64(7), Name = reader.GetString(8), Bio = reader.IsDBNull(9) ? null : reader.GetString(9), CreatedAt = reader.IsDBNull(10) ? (DateTime? )null : reader.GetDateTime(10), UpdatedAt = reader.IsDBNull(11) ? (DateTime? )null : reader.GetDateTime(11), Metadata = reader.IsDBNull(12) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(12)), Status = reader.IsDBNull(13) ? null : reader.GetString(13).ToAuthorsStatus() } });
                    return result;
                }
            }
        }

        private const string GetAuthorsByBookNameSql = "SELECT authors.id, authors.name, authors.bio, authors.created_at, authors.updated_at, authors.metadata, authors.status, books.id, books.name, books.author_id, books.description FROM authors INNER JOIN books ON authors.id = books.author_id WHERE books.name = @name";
        public class GetAuthorsByBookNameRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
            public Book Book { get; set; }
        };
        public class GetAuthorsByBookNameArgs
        {
            public string Name { get; set; }
        };
        public async Task<List<GetAuthorsByBookNameRow>> GetAuthorsByBookName(GetAuthorsByBookNameArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorsByBookNameSql))
                {
                    command.Parameters.AddWithValue("@name", args.Name);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetAuthorsByBookNameRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetAuthorsByBookNameRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus(), Book = new Book { Id = reader.GetFieldValue<Guid>(7), Name = reader.GetString(8), AuthorId = reader.GetInt64(9), Description = reader.IsDBNull(10) ? null : reader.GetString(10) } });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorsByBookNameSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@name", args.Name);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetAuthorsByBookNameRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetAuthorsByBookNameRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus(), Book = new Book { Id = reader.GetFieldValue<Guid>(7), Name = reader.GetString(8), AuthorId = reader.GetInt64(9), Description = reader.IsDBNull(10) ? null : reader.GetString(10) } });
                    return result;
                }
            }
        }

        private const string CreateExtendedBioSql = "INSERT INTO extended.bios (author_name, name, bio_type) VALUES (@author_name, @name, @bio_type)";
        public class CreateExtendedBioArgs
        {
            public string AuthorName { get; set; }
            public string Name { get; set; }
            public ExtendedBioType? BioType { get; set; }
        };
        public async Task CreateExtendedBio(CreateExtendedBioArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateExtendedBioSql))
                {
                    command.Parameters.AddWithValue("@author_name", args.AuthorName);
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@bio_type", args.BioType ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateExtendedBioSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@author_name", args.AuthorName);
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@bio_type", args.BioType ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetFirstExtendedBioByTypeSql = "SELECT author_name, name, bio_type FROM extended.bios WHERE bio_type = @bio_type LIMIT 1";
        public class GetFirstExtendedBioByTypeRow
        {
            public string AuthorName { get; set; }
            public string Name { get; set; }
            public ExtendedBioType? BioType { get; set; }
        };
        public class GetFirstExtendedBioByTypeArgs
        {
            public ExtendedBioType? BioType { get; set; }
        };
        public async Task<GetFirstExtendedBioByTypeRow> GetFirstExtendedBioByType(GetFirstExtendedBioByTypeArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetFirstExtendedBioByTypeSql))
                {
                    command.Parameters.AddWithValue("@bio_type", args.BioType ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetFirstExtendedBioByTypeRow
                            {
                                AuthorName = reader.GetString(0),
                                Name = reader.GetString(1),
                                BioType = reader.IsDBNull(2) ? (ExtendedBioType? )null : reader.GetString(2).ToExtendedBioType()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetFirstExtendedBioByTypeSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@bio_type", args.BioType ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetFirstExtendedBioByTypeRow
                        {
                            AuthorName = reader.GetString(0),
                            Name = reader.GetString(1),
                            BioType = reader.IsDBNull(2) ? (ExtendedBioType? )null : reader.GetString(2).ToExtendedBioType()
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncateExtendedBiosSql = "TRUNCATE TABLE extended.bios";
        public async Task TruncateExtendedBios()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncateExtendedBiosSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncateExtendedBiosSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetAuthorsWithDuplicateParamsSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE (name = @author_name OR bio LIKE '%' || @author_name || '%') AND (id > @min_id OR id < @min_id + 1000) AND created_at >= @date_filter AND updated_at >= @date_filter";
        public class GetAuthorsWithDuplicateParamsRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorsWithDuplicateParamsArgs
        {
            public string AuthorName { get; set; }
            public long? MinId { get; set; }
            public DateTime? DateFilter { get; set; }
        };
        public async Task<List<GetAuthorsWithDuplicateParamsRow>> GetAuthorsWithDuplicateParams(GetAuthorsWithDuplicateParamsArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorsWithDuplicateParamsSql))
                {
                    command.Parameters.AddWithValue("@author_name", args.AuthorName ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@min_id", args.MinId ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@date_filter", NpgsqlDbType.Timestamp, args.DateFilter ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetAuthorsWithDuplicateParamsRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetAuthorsWithDuplicateParamsRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorsWithDuplicateParamsSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@author_name", args.AuthorName ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@min_id", args.MinId ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@date_filter", NpgsqlDbType.Timestamp, args.DateFilter ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetAuthorsWithDuplicateParamsRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetAuthorsWithDuplicateParamsRow { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() });
                    return result;
                }
            }
        }

        private const string GetAuthorWithPentaParamSql = "SELECT id, name, bio, created_at, updated_at, metadata, status FROM authors WHERE name = @search_value OR bio LIKE '%' || @search_value || '%' OR CAST(id AS TEXT) = @search_value OR created_at::TEXT LIKE '%' || @search_value || '%' OR (LENGTH(@search_value) > 0 AND name IS NOT NULL) LIMIT 1";
        public class GetAuthorWithPentaParamRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class GetAuthorWithPentaParamArgs
        {
            public string SearchValue { get; set; }
        };
        public async Task<GetAuthorWithPentaParamRow> GetAuthorWithPentaParam(GetAuthorWithPentaParamArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorWithPentaParamSql))
                {
                    command.Parameters.AddWithValue("@search_value", args.SearchValue ?? (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetAuthorWithPentaParamRow
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorWithPentaParamSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@search_value", args.SearchValue ?? (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetAuthorWithPentaParamRow
                        {
                            Id = reader.GetInt64(0),
                            Name = reader.GetString(1),
                            Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                            Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                            Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                        };
                    }
                }
            }

            return null;
        }

        private const string CreateAuthorWithMetadataSql = "INSERT INTO authors (id, name, bio, metadata) VALUES (@id, @name, @bio, @metadata) RETURNING id, name, bio, created_at, updated_at, metadata, status";
        public class CreateAuthorWithMetadataRow
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public DateTime? CreatedAt { get; set; }
            public DateTime? UpdatedAt { get; set; }
            public JsonElement? Metadata { get; set; }
            public AuthorsStatus Status { get; set; }
        };
        public class CreateAuthorWithMetadataArgs
        {
            public long Id { get; set; }
            public string Name { get; set; }
            public string Bio { get; set; }
            public JsonElement? Metadata { get; set; }
        };
        public async Task<CreateAuthorWithMetadataRow> CreateAuthorWithMetadata(CreateAuthorWithMetadataArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(CreateAuthorWithMetadataSql))
                {
                    command.Parameters.AddWithValue("@id", args.Id);
                    command.Parameters.AddWithValue("@name", args.Name);
                    command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@metadata", NpgsqlDbType.Json, args.Metadata.HasValue ? (object)args.Metadata.Value : (object)DBNull.Value);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new CreateAuthorWithMetadataRow
                            {
                                Id = reader.GetInt64(0),
                                Name = reader.GetString(1),
                                Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                                Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                                Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = CreateAuthorWithMetadataSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@id", args.Id);
                command.Parameters.AddWithValue("@name", args.Name);
                command.Parameters.AddWithValue("@bio", args.Bio ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@metadata", NpgsqlDbType.Json, args.Metadata.HasValue ? (object)args.Metadata.Value : (object)DBNull.Value);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new CreateAuthorWithMetadataRow
                        {
                            Id = reader.GetInt64(0),
                            Name = reader.GetString(1),
                            Bio = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4),
                            Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)),
                            Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus()
                        };
                    }
                }
            }

            return null;
        }

        private const string GetAuthorsWithJsonMetadataSql = "SELECT authors.id, authors.name, authors.bio, authors.created_at, authors.updated_at, authors.metadata, authors.status, books.name as book_name FROM authors LEFT JOIN books ON authors.id = books.author_id WHERE authors.metadata IS NOT NULL ORDER BY authors.name";
        public class GetAuthorsWithJsonMetadataRow
        {
            public Author Author { get; set; }
            public string BookName { get; set; }
        };
        public async Task<List<GetAuthorsWithJsonMetadataRow>> GetAuthorsWithJsonMetadata()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetAuthorsWithJsonMetadataSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        var result = new List<GetAuthorsWithJsonMetadataRow>();
                        while (await reader.ReadAsync())
                            result.Add(new GetAuthorsWithJsonMetadataRow { Author = new Author { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() }, BookName = reader.IsDBNull(7) ? null : reader.GetString(7) });
                        return result;
                    }
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetAuthorsWithJsonMetadataSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    var result = new List<GetAuthorsWithJsonMetadataRow>();
                    while (await reader.ReadAsync())
                        result.Add(new GetAuthorsWithJsonMetadataRow { Author = new Author { Id = reader.GetInt64(0), Name = reader.GetString(1), Bio = reader.IsDBNull(2) ? null : reader.GetString(2), CreatedAt = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3), UpdatedAt = reader.IsDBNull(4) ? (DateTime? )null : reader.GetDateTime(4), Metadata = reader.IsDBNull(5) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(5)), Status = reader.IsDBNull(6) ? null : reader.GetString(6).ToAuthorsStatus() }, BookName = reader.IsDBNull(7) ? null : reader.GetString(7) });
                    return result;
                }
            }
        }

        private const string GetPostgresFunctionsSql = "SELECT MAX(c_integer) AS max_integer, MAX(c_varchar) AS max_varchar, MAX(c_timestamp) AS max_timestamp FROM postgres_datetime_types CROSS JOIN postgres_numeric_types CROSS JOIN postgres_string_types";
        public class GetPostgresFunctionsRow
        {
            public int? MaxInteger { get; set; }
            public string MaxVarchar { get; set; }
            public DateTime MaxTimestamp { get; set; }
        };
        public async Task<GetPostgresFunctionsRow> GetPostgresFunctions()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresFunctionsSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresFunctionsRow
                            {
                                MaxInteger = reader.IsDBNull(0) ? (int? )null : reader.GetInt32(0),
                                MaxVarchar = reader.IsDBNull(1) ? null : reader.GetString(1),
                                MaxTimestamp = reader.GetDateTime(2)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresFunctionsSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresFunctionsRow
                        {
                            MaxInteger = reader.IsDBNull(0) ? (int? )null : reader.GetInt32(0),
                            MaxVarchar = reader.IsDBNull(1) ? null : reader.GetString(1),
                            MaxTimestamp = reader.GetDateTime(2)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresNumericTypesSql = "INSERT INTO postgres_numeric_types ( c_boolean, c_bit, c_smallint, c_integer, c_bigint, c_decimal, c_numeric, c_real, c_double_precision, c_money ) VALUES (@c_boolean, @c_bit, @c_smallint, @c_integer, @c_bigint, @c_decimal, @c_numeric, @c_real, @c_double_precision, @c_money)";
        public class InsertPostgresNumericTypesArgs
        {
            public bool? CBoolean { get; set; }
            public byte[] CBit { get; set; }
            public short? CSmallint { get; set; }
            public int? CInteger { get; set; }
            public long? CBigint { get; set; }
            public decimal? CDecimal { get; set; }
            public decimal? CNumeric { get; set; }
            public float? CReal { get; set; }
            public double? CDoublePrecision { get; set; }
            public decimal? CMoney { get; set; }
        };
        public async Task InsertPostgresNumericTypes(InsertPostgresNumericTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresNumericTypesSql))
                {
                    command.Parameters.AddWithValue("@c_boolean", args.CBoolean ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_bit", args.CBit ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_smallint", args.CSmallint ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_integer", args.CInteger ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_bigint", args.CBigint ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_decimal", args.CDecimal ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_numeric", args.CNumeric ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_real", args.CReal ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_double_precision", args.CDoublePrecision ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_money", NpgsqlDbType.Money, args.CMoney ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresNumericTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_boolean", args.CBoolean ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_bit", args.CBit ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_smallint", args.CSmallint ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_integer", args.CInteger ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_bigint", args.CBigint ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_decimal", args.CDecimal ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_numeric", args.CNumeric ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_real", args.CReal ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_double_precision", args.CDoublePrecision ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_money", NpgsqlDbType.Money, args.CMoney ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresNumericTypesSql = "SELECT c_boolean, c_bit, c_smallint, c_integer, c_bigint, c_decimal, c_numeric, c_real, c_double_precision, c_money FROM postgres_numeric_types LIMIT 1";
        public class GetPostgresNumericTypesRow
        {
            public bool? CBoolean { get; set; }
            public byte[] CBit { get; set; }
            public short? CSmallint { get; set; }
            public int? CInteger { get; set; }
            public long? CBigint { get; set; }
            public decimal? CDecimal { get; set; }
            public decimal? CNumeric { get; set; }
            public float? CReal { get; set; }
            public double? CDoublePrecision { get; set; }
            public decimal? CMoney { get; set; }
        };
        public async Task<GetPostgresNumericTypesRow> GetPostgresNumericTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresNumericTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresNumericTypesRow
                            {
                                CBoolean = reader.IsDBNull(0) ? (bool? )null : reader.GetBoolean(0),
                                CBit = reader.IsDBNull(1) ? null : reader.GetFieldValue<byte[]>(1),
                                CSmallint = reader.IsDBNull(2) ? (short? )null : reader.GetInt16(2),
                                CInteger = reader.IsDBNull(3) ? (int? )null : reader.GetInt32(3),
                                CBigint = reader.IsDBNull(4) ? (long? )null : reader.GetInt64(4),
                                CDecimal = reader.IsDBNull(5) ? (decimal? )null : reader.GetDecimal(5),
                                CNumeric = reader.IsDBNull(6) ? (decimal? )null : reader.GetDecimal(6),
                                CReal = reader.IsDBNull(7) ? (float? )null : reader.GetFloat(7),
                                CDoublePrecision = reader.IsDBNull(8) ? (double? )null : reader.GetDouble(8),
                                CMoney = reader.IsDBNull(9) ? (decimal? )null : reader.GetDecimal(9)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresNumericTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresNumericTypesRow
                        {
                            CBoolean = reader.IsDBNull(0) ? (bool? )null : reader.GetBoolean(0),
                            CBit = reader.IsDBNull(1) ? null : reader.GetFieldValue<byte[]>(1),
                            CSmallint = reader.IsDBNull(2) ? (short? )null : reader.GetInt16(2),
                            CInteger = reader.IsDBNull(3) ? (int? )null : reader.GetInt32(3),
                            CBigint = reader.IsDBNull(4) ? (long? )null : reader.GetInt64(4),
                            CDecimal = reader.IsDBNull(5) ? (decimal? )null : reader.GetDecimal(5),
                            CNumeric = reader.IsDBNull(6) ? (decimal? )null : reader.GetDecimal(6),
                            CReal = reader.IsDBNull(7) ? (float? )null : reader.GetFloat(7),
                            CDoublePrecision = reader.IsDBNull(8) ? (double? )null : reader.GetDouble(8),
                            CMoney = reader.IsDBNull(9) ? (decimal? )null : reader.GetDecimal(9)
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresNumericTypesSql = "TRUNCATE TABLE postgres_numeric_types";
        public async Task TruncatePostgresNumericTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresNumericTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresNumericTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresNumericTypesCntSql = "SELECT c_boolean, c_bit, c_smallint, c_integer, c_bigint, c_decimal, c_numeric, c_real, c_double_precision, c_money, COUNT(*) AS cnt FROM postgres_numeric_types GROUP BY c_boolean, c_bit, c_smallint, c_integer, c_bigint, c_decimal, c_numeric, c_real, c_double_precision, c_money LIMIT 1";
        public class GetPostgresNumericTypesCntRow
        {
            public bool? CBoolean { get; set; }
            public byte[] CBit { get; set; }
            public short? CSmallint { get; set; }
            public int? CInteger { get; set; }
            public long? CBigint { get; set; }
            public decimal? CDecimal { get; set; }
            public decimal? CNumeric { get; set; }
            public float? CReal { get; set; }
            public double? CDoublePrecision { get; set; }
            public decimal? CMoney { get; set; }
            public long Cnt { get; set; }
        };
        public async Task<GetPostgresNumericTypesCntRow> GetPostgresNumericTypesCnt()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresNumericTypesCntSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresNumericTypesCntRow
                            {
                                CBoolean = reader.IsDBNull(0) ? (bool? )null : reader.GetBoolean(0),
                                CBit = reader.IsDBNull(1) ? null : reader.GetFieldValue<byte[]>(1),
                                CSmallint = reader.IsDBNull(2) ? (short? )null : reader.GetInt16(2),
                                CInteger = reader.IsDBNull(3) ? (int? )null : reader.GetInt32(3),
                                CBigint = reader.IsDBNull(4) ? (long? )null : reader.GetInt64(4),
                                CDecimal = reader.IsDBNull(5) ? (decimal? )null : reader.GetDecimal(5),
                                CNumeric = reader.IsDBNull(6) ? (decimal? )null : reader.GetDecimal(6),
                                CReal = reader.IsDBNull(7) ? (float? )null : reader.GetFloat(7),
                                CDoublePrecision = reader.IsDBNull(8) ? (double? )null : reader.GetDouble(8),
                                CMoney = reader.IsDBNull(9) ? (decimal? )null : reader.GetDecimal(9),
                                Cnt = reader.GetInt64(10)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresNumericTypesCntSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresNumericTypesCntRow
                        {
                            CBoolean = reader.IsDBNull(0) ? (bool? )null : reader.GetBoolean(0),
                            CBit = reader.IsDBNull(1) ? null : reader.GetFieldValue<byte[]>(1),
                            CSmallint = reader.IsDBNull(2) ? (short? )null : reader.GetInt16(2),
                            CInteger = reader.IsDBNull(3) ? (int? )null : reader.GetInt32(3),
                            CBigint = reader.IsDBNull(4) ? (long? )null : reader.GetInt64(4),
                            CDecimal = reader.IsDBNull(5) ? (decimal? )null : reader.GetDecimal(5),
                            CNumeric = reader.IsDBNull(6) ? (decimal? )null : reader.GetDecimal(6),
                            CReal = reader.IsDBNull(7) ? (float? )null : reader.GetFloat(7),
                            CDoublePrecision = reader.IsDBNull(8) ? (double? )null : reader.GetDouble(8),
                            CMoney = reader.IsDBNull(9) ? (decimal? )null : reader.GetDecimal(9),
                            Cnt = reader.GetInt64(10)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresNumericTypesBatchSql = "COPY postgres_numeric_types (c_boolean, c_bit, c_smallint, c_integer, c_bigint, c_decimal, c_numeric, c_real, c_double_precision, c_money) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresNumericTypesBatchArgs
        {
            public bool? CBoolean { get; set; }
            public byte[] CBit { get; set; }
            public short? CSmallint { get; set; }
            public int? CInteger { get; set; }
            public long? CBigint { get; set; }
            public decimal? CDecimal { get; set; }
            public decimal? CNumeric { get; set; }
            public float? CReal { get; set; }
            public double? CDoublePrecision { get; set; }
            public decimal? CMoney { get; set; }
        };
        public async Task InsertPostgresNumericTypesBatch(List<InsertPostgresNumericTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresNumericTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CBoolean ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CBit ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CSmallint ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CInteger ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CBigint ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CDecimal ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CNumeric ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CReal ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CDoublePrecision ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CMoney ?? (object)DBNull.Value, NpgsqlDbType.Money);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string InsertPostgresStringTypesSql = "INSERT INTO postgres_string_types ( c_char, c_varchar, c_character_varying, c_bpchar, c_text ) VALUES (@c_char, @c_varchar, @c_character_varying, @c_bpchar, @c_text)";
        public class InsertPostgresStringTypesArgs
        {
            public string CChar { get; set; }
            public string CVarchar { get; set; }
            public string CCharacterVarying { get; set; }
            public string CBpchar { get; set; }
            public string CText { get; set; }
        };
        public async Task InsertPostgresStringTypes(InsertPostgresStringTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresStringTypesSql))
                {
                    command.Parameters.AddWithValue("@c_char", args.CChar ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_varchar", args.CVarchar ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_character_varying", args.CCharacterVarying ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_bpchar", args.CBpchar ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_text", args.CText ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresStringTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_char", args.CChar ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_varchar", args.CVarchar ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_character_varying", args.CCharacterVarying ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_bpchar", args.CBpchar ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_text", args.CText ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string InsertPostgresStringTypesBatchSql = "COPY postgres_string_types (c_char, c_varchar, c_character_varying, c_bpchar, c_text) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresStringTypesBatchArgs
        {
            public string CChar { get; set; }
            public string CVarchar { get; set; }
            public string CCharacterVarying { get; set; }
            public string CBpchar { get; set; }
            public string CText { get; set; }
        };
        public async Task InsertPostgresStringTypesBatch(List<InsertPostgresStringTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresStringTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CChar ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CVarchar ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CCharacterVarying ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CBpchar ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CText ?? (object)DBNull.Value);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string GetPostgresStringTypesSql = "SELECT c_char, c_varchar, c_character_varying, c_bpchar, c_text FROM postgres_string_types LIMIT 1";
        public class GetPostgresStringTypesRow
        {
            public string CChar { get; set; }
            public string CVarchar { get; set; }
            public string CCharacterVarying { get; set; }
            public string CBpchar { get; set; }
            public string CText { get; set; }
        };
        public async Task<GetPostgresStringTypesRow> GetPostgresStringTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresStringTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresStringTypesRow
                            {
                                CChar = reader.IsDBNull(0) ? null : reader.GetString(0),
                                CVarchar = reader.IsDBNull(1) ? null : reader.GetString(1),
                                CCharacterVarying = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CBpchar = reader.IsDBNull(3) ? null : reader.GetString(3),
                                CText = reader.IsDBNull(4) ? null : reader.GetString(4)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresStringTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresStringTypesRow
                        {
                            CChar = reader.IsDBNull(0) ? null : reader.GetString(0),
                            CVarchar = reader.IsDBNull(1) ? null : reader.GetString(1),
                            CCharacterVarying = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CBpchar = reader.IsDBNull(3) ? null : reader.GetString(3),
                            CText = reader.IsDBNull(4) ? null : reader.GetString(4)
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresStringTypesSql = "TRUNCATE TABLE postgres_string_types";
        public async Task TruncatePostgresStringTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresStringTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresStringTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresStringTypesCntSql = "SELECT c_char, c_varchar, c_character_varying, c_bpchar, c_text, COUNT(*) AS cnt FROM postgres_string_types GROUP BY c_char, c_varchar, c_character_varying, c_bpchar, c_text LIMIT 1";
        public class GetPostgresStringTypesCntRow
        {
            public string CChar { get; set; }
            public string CVarchar { get; set; }
            public string CCharacterVarying { get; set; }
            public string CBpchar { get; set; }
            public string CText { get; set; }
            public long Cnt { get; set; }
        };
        public async Task<GetPostgresStringTypesCntRow> GetPostgresStringTypesCnt()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresStringTypesCntSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresStringTypesCntRow
                            {
                                CChar = reader.IsDBNull(0) ? null : reader.GetString(0),
                                CVarchar = reader.IsDBNull(1) ? null : reader.GetString(1),
                                CCharacterVarying = reader.IsDBNull(2) ? null : reader.GetString(2),
                                CBpchar = reader.IsDBNull(3) ? null : reader.GetString(3),
                                CText = reader.IsDBNull(4) ? null : reader.GetString(4),
                                Cnt = reader.GetInt64(5)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresStringTypesCntSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresStringTypesCntRow
                        {
                            CChar = reader.IsDBNull(0) ? null : reader.GetString(0),
                            CVarchar = reader.IsDBNull(1) ? null : reader.GetString(1),
                            CCharacterVarying = reader.IsDBNull(2) ? null : reader.GetString(2),
                            CBpchar = reader.IsDBNull(3) ? null : reader.GetString(3),
                            CText = reader.IsDBNull(4) ? null : reader.GetString(4),
                            Cnt = reader.GetInt64(5)
                        };
                    }
                }
            }

            return null;
        }

        private const string GetPostgresStringTypesTextSearchSql = "WITH txt_query AS ( SELECT c_text, to_tsquery('english', @to_tsquery) AS query, to_tsvector('english', c_text) AS tsv FROM postgres_string_types WHERE c_text @@ to_tsquery('english', @to_tsquery) ) SELECT txt_query.c_text, txt_query.query, txt_query.tsv, ts_rank(tsv, query) AS rnk FROM txt_query ORDER BY rnk DESC LIMIT 1";
        public class GetPostgresStringTypesTextSearchRow
        {
            public string CText { get; set; }
            public NpgsqlTsQuery Query { get; set; }
            public NpgsqlTsVector Tsv { get; set; }
            public float Rnk { get; set; }
        };
        public class GetPostgresStringTypesTextSearchArgs
        {
            public string ToTsquery { get; set; }
        };
        public async Task<GetPostgresStringTypesTextSearchRow> GetPostgresStringTypesTextSearch(GetPostgresStringTypesTextSearchArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresStringTypesTextSearchSql))
                {
                    command.Parameters.AddWithValue("@to_tsquery", args.ToTsquery);
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresStringTypesTextSearchRow
                            {
                                CText = reader.IsDBNull(0) ? null : reader.GetString(0),
                                Query = reader.GetFieldValue<NpgsqlTsQuery>(1),
                                Tsv = reader.GetFieldValue<NpgsqlTsVector>(2),
                                Rnk = reader.GetFloat(3)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresStringTypesTextSearchSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@to_tsquery", args.ToTsquery);
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresStringTypesTextSearchRow
                        {
                            CText = reader.IsDBNull(0) ? null : reader.GetString(0),
                            Query = reader.GetFieldValue<NpgsqlTsQuery>(1),
                            Tsv = reader.GetFieldValue<NpgsqlTsVector>(2),
                            Rnk = reader.GetFloat(3)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresDateTimeTypesSql = "INSERT INTO postgres_datetime_types ( c_date, c_time, c_timestamp, c_timestamp_with_tz, c_interval, c_timestamp_noda_instant_override ) VALUES (@c_date, @c_time, @c_timestamp, @c_timestamp_with_tz, @c_interval, @c_timestamp_noda_instant_override)";
        public class InsertPostgresDateTimeTypesArgs
        {
            public DateTime? CDate { get; set; }
            public TimeSpan? CTime { get; set; }
            public DateTime? CTimestamp { get; set; }
            public DateTime? CTimestampWithTz { get; set; }
            public TimeSpan? CInterval { get; set; }
            public Instant? CTimestampNodaInstantOverride { get; set; }
        };
        public async Task InsertPostgresDateTimeTypes(InsertPostgresDateTimeTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresDateTimeTypesSql))
                {
                    command.Parameters.AddWithValue("@c_date", NpgsqlDbType.Date, args.CDate ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_time", NpgsqlDbType.Time, args.CTime ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_timestamp", NpgsqlDbType.Timestamp, args.CTimestamp ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_timestamp_with_tz", NpgsqlDbType.TimestampTz, args.CTimestampWithTz ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_interval", NpgsqlDbType.Interval, args.CInterval ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_timestamp_noda_instant_override", NpgsqlDbType.Timestamp, args.CTimestampNodaInstantOverride is null ? (object)DBNull.Value : (DateTime? )DateTime.SpecifyKind(args.CTimestampNodaInstantOverride.Value.ToDateTimeUtc(), DateTimeKind.Unspecified));
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresDateTimeTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_date", NpgsqlDbType.Date, args.CDate ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_time", NpgsqlDbType.Time, args.CTime ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_timestamp", NpgsqlDbType.Timestamp, args.CTimestamp ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_timestamp_with_tz", NpgsqlDbType.TimestampTz, args.CTimestampWithTz ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_interval", NpgsqlDbType.Interval, args.CInterval ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_timestamp_noda_instant_override", NpgsqlDbType.Timestamp, args.CTimestampNodaInstantOverride is null ? (object)DBNull.Value : (DateTime? )DateTime.SpecifyKind(args.CTimestampNodaInstantOverride.Value.ToDateTimeUtc(), DateTimeKind.Unspecified));
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresDateTimeTypesSql = "SELECT c_date, c_time, c_timestamp, c_timestamp_with_tz, c_interval, c_timestamp_noda_instant_override FROM postgres_datetime_types LIMIT 1";
        public class GetPostgresDateTimeTypesRow
        {
            public DateTime? CDate { get; set; }
            public TimeSpan? CTime { get; set; }
            public DateTime? CTimestamp { get; set; }
            public DateTime? CTimestampWithTz { get; set; }
            public TimeSpan? CInterval { get; set; }
            public Instant? CTimestampNodaInstantOverride { get; set; }
        };
        public async Task<GetPostgresDateTimeTypesRow> GetPostgresDateTimeTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresDateTimeTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresDateTimeTypesRow
                            {
                                CDate = reader.IsDBNull(0) ? (DateTime? )null : reader.GetDateTime(0),
                                CTime = reader.IsDBNull(1) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(1),
                                CTimestamp = reader.IsDBNull(2) ? (DateTime? )null : reader.GetDateTime(2),
                                CTimestampWithTz = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                CInterval = reader.IsDBNull(4) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(4),
                                CTimestampNodaInstantOverride = reader.IsDBNull(5) ? (Instant? )null : (new Func<NpgsqlDataReader, int, Instant>((r, o) =>
                                {
                                    var dt = reader.GetDateTime(o);
                                    if (dt.Kind != DateTimeKind.Utc)
                                        dt = DateTime.SpecifyKind(dt, DateTimeKind.Utc);
                                    return dt.ToInstant();
                                }))(reader, 5)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresDateTimeTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresDateTimeTypesRow
                        {
                            CDate = reader.IsDBNull(0) ? (DateTime? )null : reader.GetDateTime(0),
                            CTime = reader.IsDBNull(1) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(1),
                            CTimestamp = reader.IsDBNull(2) ? (DateTime? )null : reader.GetDateTime(2),
                            CTimestampWithTz = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            CInterval = reader.IsDBNull(4) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(4),
                            CTimestampNodaInstantOverride = reader.IsDBNull(5) ? (Instant? )null : (new Func<NpgsqlDataReader, int, Instant>((r, o) =>
                            {
                                var dt = reader.GetDateTime(o);
                                if (dt.Kind != DateTimeKind.Utc)
                                    dt = DateTime.SpecifyKind(dt, DateTimeKind.Utc);
                                return dt.ToInstant();
                            }))(reader, 5)
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresDateTimeTypesSql = "TRUNCATE TABLE postgres_datetime_types";
        public async Task TruncatePostgresDateTimeTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresDateTimeTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresDateTimeTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresDateTimeTypesCntSql = "SELECT c_date, c_time, c_timestamp, c_timestamp_with_tz, c_interval, COUNT(*) AS cnt FROM postgres_datetime_types GROUP BY c_date, c_time, c_timestamp, c_timestamp_with_tz, c_interval LIMIT 1";
        public class GetPostgresDateTimeTypesCntRow
        {
            public DateTime? CDate { get; set; }
            public TimeSpan? CTime { get; set; }
            public DateTime? CTimestamp { get; set; }
            public DateTime? CTimestampWithTz { get; set; }
            public TimeSpan? CInterval { get; set; }
            public long Cnt { get; set; }
        };
        public async Task<GetPostgresDateTimeTypesCntRow> GetPostgresDateTimeTypesCnt()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresDateTimeTypesCntSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresDateTimeTypesCntRow
                            {
                                CDate = reader.IsDBNull(0) ? (DateTime? )null : reader.GetDateTime(0),
                                CTime = reader.IsDBNull(1) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(1),
                                CTimestamp = reader.IsDBNull(2) ? (DateTime? )null : reader.GetDateTime(2),
                                CTimestampWithTz = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                                CInterval = reader.IsDBNull(4) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(4),
                                Cnt = reader.GetInt64(5)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresDateTimeTypesCntSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresDateTimeTypesCntRow
                        {
                            CDate = reader.IsDBNull(0) ? (DateTime? )null : reader.GetDateTime(0),
                            CTime = reader.IsDBNull(1) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(1),
                            CTimestamp = reader.IsDBNull(2) ? (DateTime? )null : reader.GetDateTime(2),
                            CTimestampWithTz = reader.IsDBNull(3) ? (DateTime? )null : reader.GetDateTime(3),
                            CInterval = reader.IsDBNull(4) ? (TimeSpan? )null : reader.GetFieldValue<TimeSpan>(4),
                            Cnt = reader.GetInt64(5)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresDateTimeTypesBatchSql = "COPY postgres_datetime_types (c_date, c_time, c_timestamp, c_timestamp_with_tz, c_interval) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresDateTimeTypesBatchArgs
        {
            public DateTime? CDate { get; set; }
            public TimeSpan? CTime { get; set; }
            public DateTime? CTimestamp { get; set; }
            public DateTime? CTimestampWithTz { get; set; }
            public TimeSpan? CInterval { get; set; }
        };
        public async Task InsertPostgresDateTimeTypesBatch(List<InsertPostgresDateTimeTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresDateTimeTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CDate ?? (object)DBNull.Value, NpgsqlDbType.Date);
                        await writer.WriteAsync(row.CTime ?? (object)DBNull.Value, NpgsqlDbType.Time);
                        await writer.WriteAsync(row.CTimestamp ?? (object)DBNull.Value, NpgsqlDbType.Timestamp);
                        await writer.WriteAsync(row.CTimestampWithTz ?? (object)DBNull.Value, NpgsqlDbType.TimestampTz);
                        await writer.WriteAsync(row.CInterval ?? (object)DBNull.Value, NpgsqlDbType.Interval);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string InsertPostgresNetworkTypesSql = "INSERT INTO postgres_network_types ( c_cidr, c_inet, c_macaddr, c_macaddr8 ) VALUES ( @c_cidr, @c_inet, @c_macaddr, @c_macaddr8::macaddr8 )";
        public class InsertPostgresNetworkTypesArgs
        {
            public NpgsqlCidr? CCidr { get; set; }
            public IPAddress CInet { get; set; }
            public PhysicalAddress CMacaddr { get; set; }
            public string CMacaddr8 { get; set; }
        };
        public async Task InsertPostgresNetworkTypes(InsertPostgresNetworkTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresNetworkTypesSql))
                {
                    command.Parameters.AddWithValue("@c_cidr", args.CCidr ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_inet", args.CInet ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_macaddr", args.CMacaddr ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_macaddr8", args.CMacaddr8 ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresNetworkTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_cidr", args.CCidr ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_inet", args.CInet ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_macaddr", args.CMacaddr ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_macaddr8", args.CMacaddr8 ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresNetworkTypesSql = "SELECT c_cidr, c_inet, c_macaddr, c_macaddr8::TEXT AS c_macaddr8 FROM postgres_network_types LIMIT 1";
        public class GetPostgresNetworkTypesRow
        {
            public NpgsqlCidr? CCidr { get; set; }
            public IPAddress CInet { get; set; }
            public PhysicalAddress CMacaddr { get; set; }
            public string CMacaddr8 { get; set; }
        };
        public async Task<GetPostgresNetworkTypesRow> GetPostgresNetworkTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresNetworkTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresNetworkTypesRow
                            {
                                CCidr = reader.IsDBNull(0) ? (NpgsqlCidr? )null : reader.GetFieldValue<NpgsqlCidr>(0),
                                CInet = reader.IsDBNull(1) ? null : reader.GetFieldValue<IPAddress>(1),
                                CMacaddr = reader.IsDBNull(2) ? null : reader.GetFieldValue<PhysicalAddress>(2),
                                CMacaddr8 = reader.IsDBNull(3) ? null : reader.GetString(3)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresNetworkTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresNetworkTypesRow
                        {
                            CCidr = reader.IsDBNull(0) ? (NpgsqlCidr? )null : reader.GetFieldValue<NpgsqlCidr>(0),
                            CInet = reader.IsDBNull(1) ? null : reader.GetFieldValue<IPAddress>(1),
                            CMacaddr = reader.IsDBNull(2) ? null : reader.GetFieldValue<PhysicalAddress>(2),
                            CMacaddr8 = reader.IsDBNull(3) ? null : reader.GetString(3)
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresNetworkTypesSql = "TRUNCATE TABLE postgres_network_types";
        public async Task TruncatePostgresNetworkTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresNetworkTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresNetworkTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresNetworkTypesCntSql = "SELECT c_cidr, c_inet, c_macaddr, COUNT(*) AS cnt FROM postgres_network_types GROUP BY c_cidr, c_inet, c_macaddr LIMIT 1";
        public class GetPostgresNetworkTypesCntRow
        {
            public NpgsqlCidr? CCidr { get; set; }
            public IPAddress CInet { get; set; }
            public PhysicalAddress CMacaddr { get; set; }
            public long Cnt { get; set; }
        };
        public async Task<GetPostgresNetworkTypesCntRow> GetPostgresNetworkTypesCnt()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresNetworkTypesCntSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresNetworkTypesCntRow
                            {
                                CCidr = reader.IsDBNull(0) ? (NpgsqlCidr? )null : reader.GetFieldValue<NpgsqlCidr>(0),
                                CInet = reader.IsDBNull(1) ? null : reader.GetFieldValue<IPAddress>(1),
                                CMacaddr = reader.IsDBNull(2) ? null : reader.GetFieldValue<PhysicalAddress>(2),
                                Cnt = reader.GetInt64(3)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresNetworkTypesCntSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresNetworkTypesCntRow
                        {
                            CCidr = reader.IsDBNull(0) ? (NpgsqlCidr? )null : reader.GetFieldValue<NpgsqlCidr>(0),
                            CInet = reader.IsDBNull(1) ? null : reader.GetFieldValue<IPAddress>(1),
                            CMacaddr = reader.IsDBNull(2) ? null : reader.GetFieldValue<PhysicalAddress>(2),
                            Cnt = reader.GetInt64(3)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresNetworkTypesBatchSql = "COPY postgres_network_types (c_cidr, c_inet, c_macaddr) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresNetworkTypesBatchArgs
        {
            public NpgsqlCidr? CCidr { get; set; }
            public IPAddress CInet { get; set; }
            public PhysicalAddress CMacaddr { get; set; }
        };
        public async Task InsertPostgresNetworkTypesBatch(List<InsertPostgresNetworkTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresNetworkTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CCidr ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CInet ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CMacaddr ?? (object)DBNull.Value);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string InsertPostgresSpecialTypesSql = "INSERT INTO postgres_special_types ( c_json, c_json_string_override, c_jsonb, c_jsonpath, c_xml, c_xml_string_override, c_uuid, c_enum ) VALUES ( @c_json, @c_json_string_override::json, @c_jsonb, @c_jsonpath::jsonpath, @c_xml::xml, @c_xml_string_override::xml, @c_uuid, @c_enum::c_enum )";
        public class InsertPostgresSpecialTypesArgs
        {
            public JsonElement? CJson { get; set; }
            public string CJsonStringOverride { get; set; }
            public JsonElement? CJsonb { get; set; }
            public string CJsonpath { get; set; }
            public XmlDocument CXml { get; set; }
            public string CXmlStringOverride { get; set; }
            public Guid? CUuid { get; set; }
            public CEnum? CEnum { get; set; }
        };
        public async Task InsertPostgresSpecialTypes(InsertPostgresSpecialTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresSpecialTypesSql))
                {
                    command.Parameters.AddWithValue("@c_json", NpgsqlDbType.Json, args.CJson.HasValue ? (object)args.CJson.Value : (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_json_string_override", NpgsqlDbType.Json, args.CJsonStringOverride ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_jsonb", NpgsqlDbType.Jsonb, args.CJsonb.HasValue ? (object)args.CJsonb.Value : (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_jsonpath", args.CJsonpath ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_xml", NpgsqlDbType.Xml, args.CXml != null ? args.CXml.OuterXml : (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_xml_string_override", NpgsqlDbType.Xml, args.CXmlStringOverride ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_uuid", args.CUuid ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_enum", args.CEnum ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresSpecialTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_json", NpgsqlDbType.Json, args.CJson.HasValue ? (object)args.CJson.Value : (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_json_string_override", NpgsqlDbType.Json, args.CJsonStringOverride ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_jsonb", NpgsqlDbType.Jsonb, args.CJsonb.HasValue ? (object)args.CJsonb.Value : (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_jsonpath", args.CJsonpath ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_xml", NpgsqlDbType.Xml, args.CXml != null ? args.CXml.OuterXml : (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_xml_string_override", NpgsqlDbType.Xml, args.CXmlStringOverride ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_uuid", args.CUuid ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_enum", args.CEnum ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string InsertPostgresNotNullTypesSql = "INSERT INTO postgres_not_null_types ( c_enum_not_null ) VALUES ( @c_enum_not_null::c_enum )";
        public class InsertPostgresNotNullTypesArgs
        {
            public CEnum CEnumNotNull { get; set; }
        };
        public async Task InsertPostgresNotNullTypes(InsertPostgresNotNullTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresNotNullTypesSql))
                {
                    command.Parameters.AddWithValue("@c_enum_not_null", args.CEnumNotNull);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresNotNullTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_enum_not_null", args.CEnumNotNull);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresNotNullTypesSql = "SELECT c_enum_not_null FROM postgres_not_null_types LIMIT 1";
        public class GetPostgresNotNullTypesRow
        {
            public CEnum CEnumNotNull { get; set; }
        };
        public async Task<GetPostgresNotNullTypesRow> GetPostgresNotNullTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresNotNullTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresNotNullTypesRow
                            {
                                CEnumNotNull = reader.GetString(0).ToCEnum()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresNotNullTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresNotNullTypesRow
                        {
                            CEnumNotNull = reader.GetString(0).ToCEnum()
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresNotNullTypesSql = "TRUNCATE TABLE postgres_not_null_types";
        public async Task TruncatePostgresNotNullTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresNotNullTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresNotNullTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresSpecialTypesSql = "SELECT c_json, c_json_string_override, c_jsonb, c_jsonpath, c_xml, c_xml_string_override, c_uuid, c_enum FROM postgres_special_types LIMIT 1";
        public class GetPostgresSpecialTypesRow
        {
            public JsonElement? CJson { get; set; }
            public string CJsonStringOverride { get; set; }
            public JsonElement? CJsonb { get; set; }
            public string CJsonpath { get; set; }
            public XmlDocument CXml { get; set; }
            public string CXmlStringOverride { get; set; }
            public Guid? CUuid { get; set; }
            public CEnum? CEnum { get; set; }
        };
        public async Task<GetPostgresSpecialTypesRow> GetPostgresSpecialTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresSpecialTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresSpecialTypesRow
                            {
                                CJson = reader.IsDBNull(0) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(0)),
                                CJsonStringOverride = reader.IsDBNull(1) ? null : reader.GetString(1),
                                CJsonb = reader.IsDBNull(2) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(2)),
                                CJsonpath = reader.IsDBNull(3) ? null : reader.GetString(3),
                                CXml = reader.IsDBNull(4) ? null : (new Func<NpgsqlDataReader, int, XmlDocument>((r, o) =>
                                {
                                    var xmlDoc = new XmlDocument();
                                    xmlDoc.LoadXml(r.GetString(o));
                                    return xmlDoc;
                                }))(reader, 4),
                                CXmlStringOverride = reader.IsDBNull(5) ? null : reader.GetString(5),
                                CUuid = reader.IsDBNull(6) ? (Guid? )null : reader.GetFieldValue<Guid>(6),
                                CEnum = reader.IsDBNull(7) ? (CEnum? )null : reader.GetString(7).ToCEnum()
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresSpecialTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresSpecialTypesRow
                        {
                            CJson = reader.IsDBNull(0) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(0)),
                            CJsonStringOverride = reader.IsDBNull(1) ? null : reader.GetString(1),
                            CJsonb = reader.IsDBNull(2) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(2)),
                            CJsonpath = reader.IsDBNull(3) ? null : reader.GetString(3),
                            CXml = reader.IsDBNull(4) ? null : (new Func<NpgsqlDataReader, int, XmlDocument>((r, o) =>
                            {
                                var xmlDoc = new XmlDocument();
                                xmlDoc.LoadXml(r.GetString(o));
                                return xmlDoc;
                            }))(reader, 4),
                            CXmlStringOverride = reader.IsDBNull(5) ? null : reader.GetString(5),
                            CUuid = reader.IsDBNull(6) ? (Guid? )null : reader.GetFieldValue<Guid>(6),
                            CEnum = reader.IsDBNull(7) ? (CEnum? )null : reader.GetString(7).ToCEnum()
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresSpecialTypesSql = "TRUNCATE TABLE postgres_special_types";
        public async Task TruncatePostgresSpecialTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresSpecialTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresSpecialTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string InsertPostgresSpecialTypesBatchSql = "COPY postgres_special_types (c_uuid, c_json, c_jsonb) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresSpecialTypesBatchArgs
        {
            public Guid? CUuid { get; set; }
            public JsonElement? CJson { get; set; }
            public JsonElement? CJsonb { get; set; }
        };
        public async Task InsertPostgresSpecialTypesBatch(List<InsertPostgresSpecialTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresSpecialTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CUuid ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CJson.HasValue ? (object)row.CJson.Value : (object)DBNull.Value, NpgsqlDbType.Json);
                        await writer.WriteAsync(row.CJsonb.HasValue ? (object)row.CJsonb.Value : (object)DBNull.Value, NpgsqlDbType.Jsonb);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string GetPostgresSpecialTypesCntSql = "WITH grouped_json_types AS ( SELECT c_uuid, c_json::text AS c_json, c_jsonb::text AS c_jsonb, COUNT(*) AS cnt FROM postgres_special_types GROUP BY c_uuid, c_json::text, c_jsonb::text ) SELECT c_uuid, c_json::json AS c_json, c_jsonb::jsonb AS c_jsonb, cnt FROM grouped_json_types LIMIT 1";
        public class GetPostgresSpecialTypesCntRow
        {
            public Guid? CUuid { get; set; }
            public JsonElement? CJson { get; set; }
            public JsonElement? CJsonb { get; set; }
            public long Cnt { get; set; }
        };
        public async Task<GetPostgresSpecialTypesCntRow> GetPostgresSpecialTypesCnt()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresSpecialTypesCntSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresSpecialTypesCntRow
                            {
                                CUuid = reader.IsDBNull(0) ? (Guid? )null : reader.GetFieldValue<Guid>(0),
                                CJson = reader.IsDBNull(1) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(1)),
                                CJsonb = reader.IsDBNull(2) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(2)),
                                Cnt = reader.GetInt64(3)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresSpecialTypesCntSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresSpecialTypesCntRow
                        {
                            CUuid = reader.IsDBNull(0) ? (Guid? )null : reader.GetFieldValue<Guid>(0),
                            CJson = reader.IsDBNull(1) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(1)),
                            CJsonb = reader.IsDBNull(2) ? (JsonElement? )null : JsonSerializer.Deserialize<JsonElement>(reader.GetString(2)),
                            Cnt = reader.GetInt64(3)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresArrayTypesSql = "INSERT INTO postgres_array_types ( c_bytea, c_boolean_array, c_text_array, c_integer_array, c_decimal_array, c_date_array, c_timestamp_array ) VALUES (@c_bytea, @c_boolean_array, @c_text_array, @c_integer_array, @c_decimal_array, @c_date_array, @c_timestamp_array)";
        public class InsertPostgresArrayTypesArgs
        {
            public byte[] CBytea { get; set; }
            public bool[] CBooleanArray { get; set; }
            public string[] CTextArray { get; set; }
            public int[] CIntegerArray { get; set; }
            public decimal[] CDecimalArray { get; set; }
            public DateTime[] CDateArray { get; set; }
            public DateTime[] CTimestampArray { get; set; }
        };
        public async Task InsertPostgresArrayTypes(InsertPostgresArrayTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresArrayTypesSql))
                {
                    command.Parameters.AddWithValue("@c_bytea", args.CBytea ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_boolean_array", args.CBooleanArray ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_text_array", args.CTextArray ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_integer_array", args.CIntegerArray ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_decimal_array", args.CDecimalArray ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_date_array", args.CDateArray ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_timestamp_array", args.CTimestampArray ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresArrayTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_bytea", args.CBytea ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_boolean_array", args.CBooleanArray ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_text_array", args.CTextArray ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_integer_array", args.CIntegerArray ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_decimal_array", args.CDecimalArray ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_date_array", args.CDateArray ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_timestamp_array", args.CTimestampArray ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string GetPostgresArrayTypesSql = "SELECT c_bytea, c_boolean_array, c_text_array, c_integer_array, c_decimal_array, c_date_array, c_timestamp_array FROM postgres_array_types LIMIT 1";
        public class GetPostgresArrayTypesRow
        {
            public byte[] CBytea { get; set; }
            public bool[] CBooleanArray { get; set; }
            public string[] CTextArray { get; set; }
            public int[] CIntegerArray { get; set; }
            public decimal[] CDecimalArray { get; set; }
            public DateTime[] CDateArray { get; set; }
            public DateTime[] CTimestampArray { get; set; }
        };
        public async Task<GetPostgresArrayTypesRow> GetPostgresArrayTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresArrayTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresArrayTypesRow
                            {
                                CBytea = reader.IsDBNull(0) ? null : reader.GetFieldValue<byte[]>(0),
                                CBooleanArray = reader.IsDBNull(1) ? null : reader.GetFieldValue<bool[]>(1),
                                CTextArray = reader.IsDBNull(2) ? null : reader.GetFieldValue<string[]>(2),
                                CIntegerArray = reader.IsDBNull(3) ? null : reader.GetFieldValue<int[]>(3),
                                CDecimalArray = reader.IsDBNull(4) ? null : reader.GetFieldValue<decimal[]>(4),
                                CDateArray = reader.IsDBNull(5) ? null : reader.GetFieldValue<DateTime[]>(5),
                                CTimestampArray = reader.IsDBNull(6) ? null : reader.GetFieldValue<DateTime[]>(6)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresArrayTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresArrayTypesRow
                        {
                            CBytea = reader.IsDBNull(0) ? null : reader.GetFieldValue<byte[]>(0),
                            CBooleanArray = reader.IsDBNull(1) ? null : reader.GetFieldValue<bool[]>(1),
                            CTextArray = reader.IsDBNull(2) ? null : reader.GetFieldValue<string[]>(2),
                            CIntegerArray = reader.IsDBNull(3) ? null : reader.GetFieldValue<int[]>(3),
                            CDecimalArray = reader.IsDBNull(4) ? null : reader.GetFieldValue<decimal[]>(4),
                            CDateArray = reader.IsDBNull(5) ? null : reader.GetFieldValue<DateTime[]>(5),
                            CTimestampArray = reader.IsDBNull(6) ? null : reader.GetFieldValue<DateTime[]>(6)
                        };
                    }
                }
            }

            return null;
        }

        private const string InsertPostgresArrayTypesBatchSql = "COPY postgres_array_types (c_bytea, c_boolean_array, c_text_array, c_integer_array, c_decimal_array, c_timestamp_array) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresArrayTypesBatchArgs
        {
            public byte[] CBytea { get; set; }
            public bool[] CBooleanArray { get; set; }
            public string[] CTextArray { get; set; }
            public int[] CIntegerArray { get; set; }
            public decimal[] CDecimalArray { get; set; }
            public DateTime[] CTimestampArray { get; set; }
        };
        public async Task InsertPostgresArrayTypesBatch(List<InsertPostgresArrayTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresArrayTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CBytea ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CBooleanArray ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CTextArray ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CIntegerArray ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CDecimalArray ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CTimestampArray ?? (object)DBNull.Value);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string GetPostgresArrayTypesCntSql = "SELECT c_bytea, c_boolean_array, c_text_array, c_integer_array, c_decimal_array, c_timestamp_array, COUNT(*) AS cnt FROM postgres_array_types GROUP BY c_bytea, c_boolean_array, c_text_array, c_integer_array, c_decimal_array, c_timestamp_array LIMIT 1";
        public class GetPostgresArrayTypesCntRow
        {
            public byte[] CBytea { get; set; }
            public bool[] CBooleanArray { get; set; }
            public string[] CTextArray { get; set; }
            public int[] CIntegerArray { get; set; }
            public decimal[] CDecimalArray { get; set; }
            public DateTime[] CTimestampArray { get; set; }
            public long Cnt { get; set; }
        };
        public async Task<GetPostgresArrayTypesCntRow> GetPostgresArrayTypesCnt()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresArrayTypesCntSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresArrayTypesCntRow
                            {
                                CBytea = reader.IsDBNull(0) ? null : reader.GetFieldValue<byte[]>(0),
                                CBooleanArray = reader.IsDBNull(1) ? null : reader.GetFieldValue<bool[]>(1),
                                CTextArray = reader.IsDBNull(2) ? null : reader.GetFieldValue<string[]>(2),
                                CIntegerArray = reader.IsDBNull(3) ? null : reader.GetFieldValue<int[]>(3),
                                CDecimalArray = reader.IsDBNull(4) ? null : reader.GetFieldValue<decimal[]>(4),
                                CTimestampArray = reader.IsDBNull(5) ? null : reader.GetFieldValue<DateTime[]>(5),
                                Cnt = reader.GetInt64(6)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresArrayTypesCntSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresArrayTypesCntRow
                        {
                            CBytea = reader.IsDBNull(0) ? null : reader.GetFieldValue<byte[]>(0),
                            CBooleanArray = reader.IsDBNull(1) ? null : reader.GetFieldValue<bool[]>(1),
                            CTextArray = reader.IsDBNull(2) ? null : reader.GetFieldValue<string[]>(2),
                            CIntegerArray = reader.IsDBNull(3) ? null : reader.GetFieldValue<int[]>(3),
                            CDecimalArray = reader.IsDBNull(4) ? null : reader.GetFieldValue<decimal[]>(4),
                            CTimestampArray = reader.IsDBNull(5) ? null : reader.GetFieldValue<DateTime[]>(5),
                            Cnt = reader.GetInt64(6)
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresArrayTypesSql = "TRUNCATE TABLE postgres_array_types";
        public async Task TruncatePostgresArrayTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresArrayTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresArrayTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string InsertPostgresGeoTypesSql = "INSERT INTO postgres_geometric_types ( c_point, c_line, c_lseg, c_box, c_path, c_polygon, c_circle ) VALUES (@c_point, @c_line, @c_lseg, @c_box, @c_path, @c_polygon, @c_circle)";
        public class InsertPostgresGeoTypesArgs
        {
            public NpgsqlPoint? CPoint { get; set; }
            public NpgsqlLine? CLine { get; set; }
            public NpgsqlLSeg? CLseg { get; set; }
            public NpgsqlBox? CBox { get; set; }
            public NpgsqlPath? CPath { get; set; }
            public NpgsqlPolygon? CPolygon { get; set; }
            public NpgsqlCircle? CCircle { get; set; }
        };
        public async Task InsertPostgresGeoTypes(InsertPostgresGeoTypesArgs args)
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(InsertPostgresGeoTypesSql))
                {
                    command.Parameters.AddWithValue("@c_point", args.CPoint ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_line", args.CLine ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_lseg", args.CLseg ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_box", args.CBox ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_path", args.CPath ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_polygon", args.CPolygon ?? (object)DBNull.Value);
                    command.Parameters.AddWithValue("@c_circle", args.CCircle ?? (object)DBNull.Value);
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = InsertPostgresGeoTypesSql;
                command.Transaction = Transaction;
                command.Parameters.AddWithValue("@c_point", args.CPoint ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_line", args.CLine ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_lseg", args.CLseg ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_box", args.CBox ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_path", args.CPath ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_polygon", args.CPolygon ?? (object)DBNull.Value);
                command.Parameters.AddWithValue("@c_circle", args.CCircle ?? (object)DBNull.Value);
                await command.ExecuteNonQueryAsync();
            }
        }

        private const string InsertPostgresGeoTypesBatchSql = "COPY postgres_geometric_types (c_point, c_line, c_lseg, c_box, c_path, c_polygon, c_circle) FROM STDIN (FORMAT BINARY)";
        public class InsertPostgresGeoTypesBatchArgs
        {
            public NpgsqlPoint? CPoint { get; set; }
            public NpgsqlLine? CLine { get; set; }
            public NpgsqlLSeg? CLseg { get; set; }
            public NpgsqlBox? CBox { get; set; }
            public NpgsqlPath? CPath { get; set; }
            public NpgsqlPolygon? CPolygon { get; set; }
            public NpgsqlCircle? CCircle { get; set; }
        };
        public async Task InsertPostgresGeoTypesBatch(List<InsertPostgresGeoTypesBatchArgs> args)
        {
            using (var connection = DataSource != null ? DataSource.CreateConnection() : new NpgsqlConnection(ConnectionString))
            {
                await connection.OpenAsync();
                using (var writer = await connection.BeginBinaryImportAsync(InsertPostgresGeoTypesBatchSql))
                {
                    foreach (var row in args)
                    {
                        await writer.StartRowAsync();
                        await writer.WriteAsync(row.CPoint ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CLine ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CLseg ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CBox ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CPath ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CPolygon ?? (object)DBNull.Value);
                        await writer.WriteAsync(row.CCircle ?? (object)DBNull.Value);
                    }

                    await writer.CompleteAsync();
                }

                await connection.CloseAsync();
            }
        }

        private const string GetPostgresGeoTypesSql = "SELECT c_point, c_line, c_lseg, c_box, c_path, c_polygon, c_circle FROM postgres_geometric_types LIMIT 1";
        public class GetPostgresGeoTypesRow
        {
            public NpgsqlPoint? CPoint { get; set; }
            public NpgsqlLine? CLine { get; set; }
            public NpgsqlLSeg? CLseg { get; set; }
            public NpgsqlBox? CBox { get; set; }
            public NpgsqlPath? CPath { get; set; }
            public NpgsqlPolygon? CPolygon { get; set; }
            public NpgsqlCircle? CCircle { get; set; }
        };
        public async Task<GetPostgresGeoTypesRow> GetPostgresGeoTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(GetPostgresGeoTypesSql))
                {
                    using (var reader = await command.ExecuteReaderAsync())
                    {
                        if (await reader.ReadAsync())
                        {
                            return new GetPostgresGeoTypesRow
                            {
                                CPoint = reader.IsDBNull(0) ? (NpgsqlPoint? )null : reader.GetFieldValue<NpgsqlPoint>(0),
                                CLine = reader.IsDBNull(1) ? (NpgsqlLine? )null : reader.GetFieldValue<NpgsqlLine>(1),
                                CLseg = reader.IsDBNull(2) ? (NpgsqlLSeg? )null : reader.GetFieldValue<NpgsqlLSeg>(2),
                                CBox = reader.IsDBNull(3) ? (NpgsqlBox? )null : reader.GetFieldValue<NpgsqlBox>(3),
                                CPath = reader.IsDBNull(4) ? (NpgsqlPath? )null : reader.GetFieldValue<NpgsqlPath>(4),
                                CPolygon = reader.IsDBNull(5) ? (NpgsqlPolygon? )null : reader.GetFieldValue<NpgsqlPolygon>(5),
                                CCircle = reader.IsDBNull(6) ? (NpgsqlCircle? )null : reader.GetFieldValue<NpgsqlCircle>(6)
                            };
                        }
                    }
                }

                return null;
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = GetPostgresGeoTypesSql;
                command.Transaction = Transaction;
                using (var reader = await command.ExecuteReaderAsync())
                {
                    if (await reader.ReadAsync())
                    {
                        return new GetPostgresGeoTypesRow
                        {
                            CPoint = reader.IsDBNull(0) ? (NpgsqlPoint? )null : reader.GetFieldValue<NpgsqlPoint>(0),
                            CLine = reader.IsDBNull(1) ? (NpgsqlLine? )null : reader.GetFieldValue<NpgsqlLine>(1),
                            CLseg = reader.IsDBNull(2) ? (NpgsqlLSeg? )null : reader.GetFieldValue<NpgsqlLSeg>(2),
                            CBox = reader.IsDBNull(3) ? (NpgsqlBox? )null : reader.GetFieldValue<NpgsqlBox>(3),
                            CPath = reader.IsDBNull(4) ? (NpgsqlPath? )null : reader.GetFieldValue<NpgsqlPath>(4),
                            CPolygon = reader.IsDBNull(5) ? (NpgsqlPolygon? )null : reader.GetFieldValue<NpgsqlPolygon>(5),
                            CCircle = reader.IsDBNull(6) ? (NpgsqlCircle? )null : reader.GetFieldValue<NpgsqlCircle>(6)
                        };
                    }
                }
            }

            return null;
        }

        private const string TruncatePostgresGeoTypesSql = "TRUNCATE TABLE postgres_geometric_types";
        public async Task TruncatePostgresGeoTypes()
        {
            if (Transaction == null)
            {
                if (DataSource == null)
                    throw new InvalidOperationException("Transaction is null, but datasource is also null.");
                using (var command = DataSource.CreateCommand(TruncatePostgresGeoTypesSql))
                {
                    await command.ExecuteNonQueryAsync();
                    return;
                }
            }

            if (Transaction?.Connection == null || Transaction?.Connection.State != ConnectionState.Open)
                throw new InvalidOperationException("Transaction is provided, but its connection is null.");
            using (var command = Transaction.Connection.CreateCommand())
            {
                command.CommandText = TruncatePostgresGeoTypesSql;
                command.Transaction = Transaction;
                await command.ExecuteNonQueryAsync();
            }
        }
    }
}